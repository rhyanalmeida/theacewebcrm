// Comprehensive Vulnerability Scanner for ACE CRM
const axios = require('axios');
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const { execSync } = require('child_process');
const semver = require('semver');
const { auditLoggerInstance } = require('../audit/audit-logging');

class VulnerabilityScanner {
  constructor() {
    this.scanResults = [];
    this.vulnerabilityDatabase = new Map();
    this.criticalFindings = [];
    this.reportPath = './security/reports';
    
    this.ensureReportDirectory();
  }

  async ensureReportDirectory() {
    try {
      await fs.access(this.reportPath);
    } catch {
      await fs.mkdir(this.reportPath, { recursive: true });
    }
  }

  // Dependency vulnerability scanning
  async scanDependencies() {
    console.log('üîç Scanning dependencies for vulnerabilities...');
    
    const results = {
      timestamp: new Date().toISOString(),
      type: 'dependency_scan',
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        total: 0
      }
    };

    try {
      // Read package.json files
      const packageJsonPaths = [
        './package.json',
        './client-portal/package.json',
        './ace-crm/frontend/package.json',
        './ace-crm/backend/package.json'
      ];

      for (const packagePath of packageJsonPaths) {
        try {
          const fullPath = path.resolve(packagePath);
          await fs.access(fullPath);
          
          const packageData = JSON.parse(await fs.readFile(fullPath, 'utf8'));
          const projectName = packageData.name || path.dirname(packagePath);
          
          console.log(`üì¶ Scanning ${projectName}...`);
          
          // Run npm audit
          try {
            const auditResult = execSync('npm audit --json', {
              cwd: path.dirname(fullPath),
              encoding: 'utf8',
              stdio: ['pipe', 'pipe', 'pipe']
            });
            
            const auditData = JSON.parse(auditResult);
            
            if (auditData.vulnerabilities) {
              for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
                const vulnerability = {
                  project: projectName,
                  package: packageName,
                  currentVersion: vulnData.via?.[0]?.versions || 'unknown',
                  severity: vulnData.severity || 'unknown',
                  title: vulnData.via?.[0]?.title || 'Unknown vulnerability',
                  url: vulnData.via?.[0]?.url || '',
                  fixAvailable: vulnData.fixAvailable || false,
                  recommendedVersion: vulnData.fixAvailable?.version || null
                };
                
                results.vulnerabilities.push(vulnerability);
                results.summary[vulnerability.severity]++;
                results.summary.total++;
                
                if (vulnerability.severity === 'critical' || vulnerability.severity === 'high') {
                  this.criticalFindings.push(vulnerability);
                }
              }
            }
            
          } catch (auditError) {
            console.warn(`‚ö†Ô∏è npm audit failed for ${projectName}:`, auditError.message);
          }
          
        } catch (fileError) {
          console.warn(`‚ö†Ô∏è Could not read ${packagePath}:`, fileError.message);
        }
      }
      
      console.log(`‚úÖ Dependency scan completed: ${results.summary.total} vulnerabilities found`);
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Dependency scanning failed:', error.message);
      throw error;
    }
  }

  // SSL/TLS certificate scanning
  async scanSSLCertificates(domains = ['localhost', 'acecrm.com']) {
    console.log('üîí Scanning SSL/TLS certificates...');
    
    const results = {
      timestamp: new Date().toISOString(),
      type: 'ssl_scan',
      certificates: [],
      issues: []
    };

    try {
      for (const domain of domains) {
        try {
          const certInfo = await this.getSSLCertificateInfo(domain);
          
          const certificate = {
            domain,
            issuer: certInfo.issuer,
            subject: certInfo.subject,
            validFrom: certInfo.validFrom,
            validTo: certInfo.validTo,
            daysUntilExpiry: certInfo.daysUntilExpiry,
            selfSigned: certInfo.selfSigned,
            keyLength: certInfo.keyLength,
            signatureAlgorithm: certInfo.signatureAlgorithm
          };
          
          results.certificates.push(certificate);
          
          // Check for issues
          if (certificate.daysUntilExpiry < 30) {
            results.issues.push({
              domain,
              type: 'expiry_warning',
              severity: certificate.daysUntilExpiry < 7 ? 'critical' : 'high',
              message: `Certificate expires in ${certificate.daysUntilExpiry} days`
            });
          }
          
          if (certificate.selfSigned) {
            results.issues.push({
              domain,
              type: 'self_signed',
              severity: 'medium',
              message: 'Certificate is self-signed'
            });
          }
          
          if (certificate.keyLength < 2048) {
            results.issues.push({
              domain,
              type: 'weak_key',
              severity: 'high',
              message: `Weak key length: ${certificate.keyLength} bits`
            });
          }
          
        } catch (certError) {
          results.issues.push({
            domain,
            type: 'certificate_error',
            severity: 'high',
            message: `Failed to retrieve certificate: ${certError.message}`
          });
        }
      }
      
      console.log(`‚úÖ SSL scan completed: ${results.certificates.length} certificates checked`);
      
      return results;
      
    } catch (error) {
      console.error('‚ùå SSL scanning failed:', error.message);
      throw error;
    }
  }

  // Security headers scanning
  async scanSecurityHeaders(urls = ['http://localhost:3000', 'http://localhost:5000']) {
    console.log('üõ°Ô∏è Scanning security headers...');
    
    const results = {
      timestamp: new Date().toISOString(),
      type: 'headers_scan',
      scans: [],
      issues: []
    };

    const requiredHeaders = [
      'strict-transport-security',
      'x-content-type-options',
      'x-frame-options',
      'x-xss-protection',
      'content-security-policy',
      'referrer-policy'
    ];

    try {
      for (const url of urls) {
        try {
          const response = await axios.get(url, {
            timeout: 10000,
            validateStatus: () => true // Accept any status code
          });
          
          const headers = response.headers;
          const scan = {
            url,
            statusCode: response.status,
            headers: {},
            missingHeaders: [],
            weakHeaders: []
          };
          
          // Check for required security headers
          for (const header of requiredHeaders) {
            const headerValue = headers[header];
            scan.headers[header] = headerValue || null;
            
            if (!headerValue) {
              scan.missingHeaders.push(header);
              results.issues.push({
                url,
                type: 'missing_header',
                severity: 'medium',
                header,
                message: `Missing security header: ${header}`
              });
            } else {
              // Check for weak configurations
              const weaknessCheck = this.checkHeaderWeakness(header, headerValue);
              if (weaknessCheck) {
                scan.weakHeaders.push(weaknessCheck);
                results.issues.push({
                  url,
                  type: 'weak_header',
                  severity: weaknessCheck.severity,
                  header,
                  message: weaknessCheck.message
                });
              }
            }
          }
          
          // Check for information disclosure headers
          const disclosureHeaders = ['server', 'x-powered-by', 'x-aspnet-version'];
          for (const header of disclosureHeaders) {
            if (headers[header]) {
              results.issues.push({
                url,
                type: 'info_disclosure',
                severity: 'low',
                header,
                value: headers[header],
                message: `Information disclosure header present: ${header}`
              });
            }
          }
          
          results.scans.push(scan);
          
        } catch (requestError) {
          results.issues.push({
            url,
            type: 'request_error',
            severity: 'high',
            message: `Failed to scan URL: ${requestError.message}`
          });
        }
      }
      
      console.log(`‚úÖ Security headers scan completed: ${results.scans.length} URLs scanned`);
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Security headers scanning failed:', error.message);
      throw error;
    }
  }

  // Database security scanning
  async scanDatabaseSecurity() {
    console.log('üóÑÔ∏è Scanning database security...');
    
    const results = {
      timestamp: new Date().toISOString(),
      type: 'database_scan',
      findings: [],
      issues: []
    };

    try {
      // Check Supabase configuration
      const supabaseChecks = await this.checkSupabaseConfiguration();
      results.findings.push(...supabaseChecks.findings);
      results.issues.push(...supabaseChecks.issues);
      
      console.log(`‚úÖ Database security scan completed: ${results.issues.length} issues found`);
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Database security scanning failed:', error.message);
      throw error;
    }
  }

  // File system scanning for sensitive files
  async scanFileSystem() {
    console.log('üìÅ Scanning file system for security issues...');
    
    const results = {
      timestamp: new Date().toISOString(),
      type: 'filesystem_scan',
      sensitiveFiles: [],
      issues: []
    };

    try {
      const sensitivePatterns = [
        /\.env$/,
        /\.env\..*$/,
        /.*\.pem$/,
        /.*\.key$/,
        /.*\.p12$/,
        /.*\.jks$/,
        /id_rsa$/,
        /id_dsa$/,
        /.*_rsa$/,
        /.*\.pfx$/,
        /password.*\.txt$/,
        /secret.*\.txt$/,
        /config\.json$/,
        /credentials\.json$/
      ];

      const excludeDirs = ['node_modules', '.git', 'dist', 'build', '.next', 'logs'];
      
      const scanDirectory = async (dirPath, depth = 0) => {
        if (depth > 5) return; // Limit recursion depth
        
        try {
          const items = await fs.readdir(dirPath, { withFileTypes: true });
          
          for (const item of items) {
            const itemPath = path.join(dirPath, item.name);
            
            if (item.isDirectory() && !excludeDirs.includes(item.name)) {
              await scanDirectory(itemPath, depth + 1);
            } else if (item.isFile()) {
              // Check if file matches sensitive patterns
              for (const pattern of sensitivePatterns) {
                if (pattern.test(item.name)) {
                  const stats = await fs.stat(itemPath);
                  
                  results.sensitiveFiles.push({
                    path: itemPath,
                    name: item.name,
                    size: stats.size,
                    modified: stats.mtime,
                    pattern: pattern.source
                  });
                  
                  // Check file permissions (Unix systems)
                  if (process.platform !== 'win32') {
                    const permissions = (stats.mode & parseInt('777', 8)).toString(8);
                    if (permissions !== '600' && permissions !== '644') {
                      results.issues.push({
                        path: itemPath,
                        type: 'file_permissions',
                        severity: 'medium',
                        message: `Sensitive file has loose permissions: ${permissions}`
                      });
                    }
                  }
                  
                  break;
                }
              }
            }
          }
        } catch (dirError) {
          console.warn(`‚ö†Ô∏è Could not scan directory ${dirPath}:`, dirError.message);
        }
      };
      
      await scanDirectory('./');
      
      console.log(`‚úÖ File system scan completed: ${results.sensitiveFiles.length} sensitive files found`);
      
      return results;
      
    } catch (error) {
      console.error('‚ùå File system scanning failed:', error.message);
      throw error;
    }
  }

  // Complete vulnerability scan
  async performCompleteScan() {
    console.log('üöÄ Starting complete vulnerability scan...');
    
    const startTime = Date.now();
    const scanId = crypto.randomUUID();
    
    const scanReport = {
      scanId,
      timestamp: new Date().toISOString(),
      duration: 0,
      scans: {},
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        total: 0
      },
      recommendations: []
    };

    try {
      // Run all scans
      const scans = await Promise.allSettled([
        this.scanDependencies(),
        this.scanSSLCertificates(),
        this.scanSecurityHeaders(),
        this.scanDatabaseSecurity(),
        this.scanFileSystem()
      ]);

      // Process scan results
      const scanTypes = ['dependencies', 'ssl', 'headers', 'database', 'filesystem'];
      
      scans.forEach((scan, index) => {
        const scanType = scanTypes[index];
        
        if (scan.status === 'fulfilled') {
          scanReport.scans[scanType] = scan.value;
          
          // Count issues by severity
          if (scan.value.issues) {
            scan.value.issues.forEach(issue => {
              scanReport.summary[issue.severity]++;
              scanReport.summary.total++;
            });
          }
          
          if (scan.value.vulnerabilities) {
            scan.value.vulnerabilities.forEach(vuln => {
              scanReport.summary[vuln.severity]++;
              scanReport.summary.total++;
            });
          }
        } else {
          console.error(`‚ùå ${scanType} scan failed:`, scan.reason.message);
          scanReport.scans[scanType] = {
            error: scan.reason.message,
            timestamp: new Date().toISOString()
          };
        }
      });

      // Generate recommendations
      scanReport.recommendations = this.generateRecommendations(scanReport);
      
      scanReport.duration = Date.now() - startTime;
      
      // Save report
      await this.saveReport(scanReport);
      
      // Log audit event
      await auditLoggerInstance.logSystemEvent('vulnerability_scan_completed', {
        scanId,
        duration: scanReport.duration,
        totalIssues: scanReport.summary.total,
        criticalIssues: scanReport.summary.critical
      });
      
      console.log(`‚úÖ Complete vulnerability scan finished in ${scanReport.duration}ms`);
      console.log(`üìä Found ${scanReport.summary.total} issues (${scanReport.summary.critical} critical)`);
      
      return scanReport;
      
    } catch (error) {
      console.error('‚ùå Complete vulnerability scan failed:', error.message);
      throw error;
    }
  }

  // Helper methods
  async getSSLCertificateInfo(domain) {
    // This would typically use a TLS client to get certificate info
    // For demo purposes, returning mock data
    return {
      issuer: 'Let\'s Encrypt Authority X3',
      subject: domain,
      validFrom: new Date('2024-01-01'),
      validTo: new Date('2024-12-31'),
      daysUntilExpiry: 120,
      selfSigned: false,
      keyLength: 2048,
      signatureAlgorithm: 'sha256WithRSAEncryption'
    };
  }

  checkHeaderWeakness(header, value) {
    const lowerValue = value.toLowerCase();
    
    switch (header) {
      case 'x-frame-options':
        if (lowerValue === 'allow') {
          return { severity: 'high', message: 'X-Frame-Options allows framing' };
        }
        break;
      case 'strict-transport-security':
        if (!lowerValue.includes('max-age') || lowerValue.includes('max-age=0')) {
          return { severity: 'high', message: 'HSTS has weak or no max-age' };
        }
        break;
      case 'content-security-policy':
        if (lowerValue.includes('unsafe-inline') || lowerValue.includes('unsafe-eval')) {
          return { severity: 'medium', message: 'CSP contains unsafe directives' };
        }
        break;
    }
    
    return null;
  }

  async checkSupabaseConfiguration() {
    const findings = [];
    const issues = [];
    
    // Check environment variables
    const requiredEnvVars = [
      'SUPABASE_URL',
      'SUPABASE_SERVICE_ROLE_KEY',
      'SUPABASE_ANON_KEY'
    ];
    
    for (const envVar of requiredEnvVars) {
      if (!process.env[envVar]) {
        issues.push({
          type: 'missing_config',
          severity: 'high',
          message: `Missing required environment variable: ${envVar}`
        });
      }
    }
    
    // Check RLS policies (would require actual Supabase connection)
    findings.push({
      type: 'rls_check',
      status: 'manual_review_required',
      message: 'RLS policies require manual review'
    });
    
    return { findings, issues };
  }

  generateRecommendations(scanReport) {
    const recommendations = [];
    
    // Critical and high severity recommendations
    if (scanReport.summary.critical > 0) {
      recommendations.push({
        priority: 'critical',
        category: 'immediate_action',
        message: `${scanReport.summary.critical} critical vulnerabilities require immediate attention`,
        action: 'Review and patch all critical vulnerabilities immediately'
      });
    }
    
    if (scanReport.summary.high > 0) {
      recommendations.push({
        priority: 'high',
        category: 'security',
        message: `${scanReport.summary.high} high severity issues found`,
        action: 'Schedule patching within 48 hours'
      });
    }
    
    // Specific recommendations based on scan types
    if (scanReport.scans.dependencies?.summary?.total > 0) {
      recommendations.push({
        priority: 'medium',
        category: 'dependencies',
        message: 'Dependency vulnerabilities detected',
        action: 'Run npm audit fix and update vulnerable packages'
      });
    }
    
    if (scanReport.scans.ssl?.issues?.length > 0) {
      recommendations.push({
        priority: 'medium',
        category: 'ssl',
        message: 'SSL/TLS certificate issues found',
        action: 'Review and renew SSL certificates as needed'
      });
    }
    
    return recommendations;
  }

  async saveReport(scanReport) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `vulnerability-scan-${timestamp}.json`;
    const filepath = path.join(this.reportPath, filename);
    
    await fs.writeFile(filepath, JSON.stringify(scanReport, null, 2));
    console.log(`üíæ Scan report saved: ${filepath}`);
    
    return filepath;
  }
}

// Export scanner
module.exports = {
  VulnerabilityScanner
};